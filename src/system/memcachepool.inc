// @generated by "php idl.php inc {input.idl.php} {output.inc}"

#if EXT_TYPE == 0

#elif EXT_TYPE == 1
"MEMCACHE_COMPRESSED", T(Int64),
"MEMCACHE_SERIALIZED", T(Int64),
"MEMCACHE_STRATEGY_STANDARD", T(Int64),
"MEMCACHE_STRATEGY_CONSISTENT", T(Int64),
"MEMCACHE_HASH_CRC32", T(Int64),
"MEMCACHE_HASH_FNV", T(Int64),
"MEMCACHE_HASH_MURMUR", T(Int64),

#elif EXT_TYPE == 2
"MemcachePool", "", NULL, "__construct", T(Void), S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.--construct.php )\n *\n *\n */", S(16384),"getstoragememcache", T(Object), S(0), "storage_id", T(Int32), NULL, NULL, S(0), "timestamp", T(Int32), NULL, NULL, S(0), "empty", T(Variant), NULL, NULL, S(1), "persistent", T(Boolean), "b:0;", "false", S(0), NULL, S(16896), "/**\n * ( excerpt from\n * http://php.net/manual/en/memcachepool.getstoragememcache.php )\n *\n * MemcachePool::getstoragememcache() is a static member to get\n * \t\tonly one instance per storage_id and thread. The timestamp is used to\n * know\n * \t\tif the stored object have old configuration and need to be recreated\n *\n * @storage_id int     Number of the storage id (used to get only one\n *                     instance per\n *                     \t\t\t\tstorage).\n * @timestamp  int     Time of the last configuration change.\n * @empty      mixed   This parameter is needed to indicate if the\n *                     memcached\n *                     \t\t\t\tobject is new and needs to be populated with the\n *                     memcached servers\n * @persistent bool    Defines if the tcp connections should be persistent\n *\n * @return     object  Returns a MemcachePool Object or NULL if we need to\n *                     create\n *                     \t\t\tnew one (next call will return a new Object).\n */", S(16896),"connect", T(Boolean), S(0), "host", T(String), NULL, NULL, S(0), "port", T(Int32), "i:0;", "0", S(0), "timeout", T(Int32), "i:0;", "0", S(0), "timeoutms", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.connect.php )\n *\n * MemcachePool::connect() establishes a connection to the memcached\n * \t\tserver. The connection, which was opened using MemcachePool::connect()\n * will be\n * \t\tautomatically closed at the end of script execution. Also you can\n * close it\n * \t\twith MemcachePool::close(). Also you can use memcache_connect()\n * function.\n *\n * @host       string  Point to the host where memcached is listening for\n *                     \t\t\t\tconnections. This parameter may also specify\n *                     other transports like\n *                     \t\t\t\tunix:///path/to/memcached.sock to use UNIX\n *                     domain sockets, in this case\n *                     \t\t\t\tport must also be set to 0.\n * @port       int     Point to the port where memcached is listening for\n *                     \t\t\t\tconnections. Set this parameter to 0 when using\n *                     UNIX domain sockets.\n * @timeout    int     Value in seconds which will be used for connecting\n *                     to the\n *                     \t\t\t\tdaemon. Think twice before changing the default\n *                     value of 1 second - you\n *                     \t\t\t\tcan lose all the advantages of caching if your\n *                     connection is too slow.\n * @timeoutms  int\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"pconnect", T(Boolean), S(0), "host", T(String), NULL, NULL, S(0), "port", T(Int32), "i:0;", "0", S(0), "timeout", T(Int32), "i:0;", "0", S(0), "timeoutms", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.pconnect.php )\n *\n * MemcachePool::pconnect() is similar to MemcachePool::connect() with the\n * \t\tdifference, that the connection it establishes is persistent. This\n * \t\tconnection is not closed after the end of script execution and by\n * \t\tMemcachePool::close() function. Also you can use memcache_pconnect()\n * function.\n *\n * @host       string  Point to the host where memcached is listening for\n *                     \t\t\t\tconnections. This parameter may also specify\n *                     other transports like\n *                     \t\t\t\tunix:///path/to/memcached.sock to use UNIX\n *                     domain sockets, in this case\n *                     \t\t\t\tport must also be set to 0.\n * @port       int     Point to the port where memcached is listening for\n *                     \t\t\t\tconnections. Set this parameter to 0 when using\n *                     UNIX domain sockets.\n * @timeout    int     Value in seconds which will be used for connecting\n *                     to the\n *                     \t\t\t\tdaemon. Think twice before changing the default\n *                     value of 1 second - you\n *                     \t\t\t\tcan lose all the advantages of caching if your\n *                     connection is too slow.\n * @timeoutms  int\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"add", T(Boolean), S(0), "key", T(String), NULL, NULL, S(0), "var", T(Variant), NULL, NULL, S(0), "flag", T(Int32), "i:0;", "0", S(0), "expire", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.add.php )\n *\n * MemcachePool::add() stores variable var with key only if such key\n * \t\tdoesn't exist at the server yet. Also you can use memcache_add()\n * function.\n *\n * @key        string  The key that will be associated with the item.\n * @var        mixed   The variable to store. Strings and integers are\n *                     stored as\n *                     \t\t\t\tis, other types are stored serialized.\n * @flag       int     Use MEMCACHE_COMPRESSED to store the item compressed\n *                     (uses\n *                     \t\t\t\tzlib).\n * @expire     int     Expiration time of the item. If it's equal to zero,\n *                     the\n *                     \t\t\t\titem will never expire. You can also use Unix\n *                     timestamp or a number of\n *                     \t\t\t\tseconds starting from current time, but in the\n *                     latter case the number of\n *                     \t\t\t\tseconds may not exceed 2592000 (30 days).\n *\n * @return     bool    Returns TRUE on success or FALSE on failure. Returns\n *                     FALSE if\n *                     \t\t\tsuch key already exist. For the rest\n *                     MemcachePool::add() behaves similarly to\n *                     \t\t\tMemcachePool::set().\n */", S(16384),"cas", T(Boolean), S(0), "key", T(String), NULL, NULL, S(0), "var", T(Variant), NULL, NULL, S(0), "flag", T(Int32), NULL, NULL, S(0), "expire", T(Int32), NULL, NULL, S(0), "cas_token", T(Double), NULL, NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.cas.php )\n *\n * MemcachePool::cas() have the same behaviour as set, but only\n * \t\tchanges the item if its was unchanged from the last time the value was\n * \t\tobtained. This is checked using CAS parameter, obtained when calling\n * get\n *\n * @key        string  The key that will be associated with the item.\n * @var        mixed   The variable to store. Strings and integers are\n *                     stored as\n *                     \t\t\t\tis, other types are stored serialized.\n * @flag       int     Use MEMCACHE_COMPRESSED to store the item compressed\n *                     (uses\n *                     \t\t\t\tzlib).\n * @expire     int     Expiration time of the item. If it's equal to zero,\n *                     the\n *                     \t\t\t\titem will never expire. You can also use Unix\n *                     timestamp or a number of\n *                     \t\t\t\tseconds starting from current time, but in the\n *                     latter case the number of\n *                     \t\t\t\tseconds may not exceed 2592000 (30 days).\n * @cas_token  float   Unique value associated with the existing item.\n *                     Generated\n *                     \t\t\t\tby memcache.\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"set", T(Boolean), S(0), "key", T(String), NULL, NULL, S(0), "var", T(Variant), NULL, NULL, S(0), "flag", T(Int32), "i:0;", "0", S(0), "expire", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.set.php )\n *\n * MemcachePool::set() stores an item var with key on the memcached\n * \t\tserver. Parameter expire is expiration time in seconds. If it's 0, the\n * item\n * \t\tnever expires (but memcached server doesn't guarantee this item to be\n * stored\n * \t\tall the time, it could be deleted from the cache to make place for\n * other\n * \t\titems). You can use MEMCACHE_COMPRESSED constant as flag value if you\n * want\n * \t\tto use on-the-fly compression (uses zlib).\n *\n * Remember that resource\n * \t\tvariables (i.e. file and connection descriptors) cannot be stored in\n * the\n * \t\tcache, because they cannot be adequately represented in serialized\n * state.\n * \t\tAlso you can use memcache_set() function.\n *\n * @key        string  The key that will be associated with the item.\n * @var        mixed   The variable to store. Strings and integers are\n *                     stored as\n *                     \t\t\t\tis, other types are stored serialized.\n * @flag       int     Use MEMCACHE_COMPRESSED to store the item compressed\n *                     (uses\n *                     \t\t\t\tzlib).\n * @expire     int     Expiration time of the item. If it's equal to zero,\n *                     the\n *                     \t\t\t\titem will never expire. You can also use Unix\n *                     timestamp or a number of\n *                     \t\t\t\tseconds starting from current time, but in the\n *                     latter case the number of\n *                     \t\t\t\tseconds may not exceed 2592000 (30 days).\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"replace", T(Boolean), S(0), "key", T(String), NULL, NULL, S(0), "var", T(Variant), NULL, NULL, S(0), "flag", T(Int32), "i:0;", "0", S(0), "expire", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.replace.php )\n *\n * MemcachePool::replace() should be used to replace value of existing\n * \t\titem with key. In case if item with such key doesn't exists,\n * \t\tMemcachePool::replace() returns FALSE. For the rest\n * MemcachePool::replace() behaves\n * \t\tsimilarly to MemcachePool::set(). Also you can use memcache_replace()\n * \t\tfunction.\n *\n * @key        string  The key that will be associated with the item.\n * @var        mixed   The variable to store. Strings and integers are\n *                     stored as\n *                     \t\t\t\tis, other types are stored serialized.\n * @flag       int     Use MEMCACHE_COMPRESSED to store the item compressed\n *                     (uses\n *                     \t\t\t\tzlib).\n * @expire     int     Expiration time of the item. If it's equal to zero,\n *                     the\n *                     \t\t\t\titem will never expire. You can also use Unix\n *                     timestamp or a number of\n *                     \t\t\t\tseconds starting from current time, but in the\n *                     latter case the number of\n *                     \t\t\t\tseconds may not exceed 2592000 (30 days).\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"get", T(Variant), S(0), "key", T(Variant), NULL, NULL, S(0), "flags", T(Variant), "N;", "null", S(1), "cas", T(Variant), "N;", "null", S(1), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.get.php )\n *\n * MemcachePool::get() returns previously stored data if an item with\n * \t\tsuch key exists on the server at this moment.\n *\n * You can pass array of keys\n * \t\tto MemcachePool::get() to get array of values. The result array will\n * contain\n * \t\tonly found key-value pairs.\n *\n * @key        mixed   The key or array of keys to fetch.\n * @flags      mixed   If present, flags fetched along with the values will\n *                     be\n *                     \t\t\t\twritten to this parameter. These flags are the\n *                     same as the ones given to\n *                     \t\t\t\tfor example MemcachePool::set(). The lowest byte\n *                     of the int is reserved for\n *                     \t\t\t\tpecl/memcache internal usage (e.g. to indicate\n *                     compression and\n *                     \t\t\t\tserialization status).\n * @cas        mixed   If present, cas key wil be fetched along with the\n *                     values\n *                     \t\t\t\tand will be written to this parameter.\n *\n * @return     mixed   Returns the string associated with the key or FALSE\n *                     on\n *                     \t\t\tfailure or if such key was not found.\n */", S(16384),"prefetch", T(Boolean), S(0), "key", T(Variant), NULL, NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.prefetch.php )\n *\n * MemcachePool::prefetch() prefetch some keys, without actual\n * \t\treturning the values of those keys. You need to call later to get, in\n * order\n * \t\tto fetch the results.\n *\n * @key        mixed   The key or array of keys to fetch.\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"delete", T(Boolean), S(0), "key", T(String), NULL, NULL, S(0), "expire", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.delete.php )\n *\n * MemcachePool::delete() deletes item with the key. If parameter\n * \t\ttimeout is specified, the item will expire after timeout seconds. Also\n * you\n * \t\tcan use memcache_delete() function.\n *\n * @key        string  The key associated with the item to delete.\n * @expire     int     Execution time of the item. If it's equal to zero,\n *                     the item\n *                     \t\t\t\twill be deleted right away whereas if you set it\n *                     to 30, the item will be\n *                     \t\t\t\tdeleted in 30 seconds.\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"increment", T(Variant), S(0), "key", T(String), NULL, NULL, S(0), "offset", T(Int32), "i:1;", "1", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.increment.php )\n *\n * MemcachePool::increment() increments value of an item by the\n * \t\tspecified value. If item specified by key was not numeric and cannot\n * be\n * \t\tconverted to a number, it will change its value to value.\n * \t\tMemcachePool::increment() does not create an item if it doesn't\n * already\n * \t\texist.\n *\n * Do not use MemcachePool::increment() with items that have been stored\n * \t\tcompressed because subsequent calls to MemcachePool::get() will fail.\n * Also you\n * \t\tcan use memcache_increment() function.\n *\n * @key        string  Key of the item to increment.\n * @offset     int     Increment the item by value.\n *\n * @return     mixed   Returns new items value on success or FALSE on\n *                     failure.\n */", S(16384),"decrement", T(Variant), S(0), "key", T(String), NULL, NULL, S(0), "offset", T(Int32), "i:1;", "1", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.decrement.php )\n *\n * MemcachePool::decrement() decrements value of the item by value.\n * \t\tSimilarly to MemcachePool::increment(), current value of the item is\n * being\n * \t\tconverted to numerical and after that value is substracted.\n *\n * New item's\n * \t\tvalue will not be less than zero.\n *\n * Do not use MemcachePool::decrement() with\n * \t\titem, which was stored compressed, because consequent call to\n * \t\tMemcachePool::get() will fail. MemcachePool::decrement() does not\n * create an item if\n * \t\tit didn't exist. Also you can use memcache_decrement() function.\n *\n * @key        string  Key of the item do decrement.\n * @offset     int     Decrement the item by value.\n *\n * @return     mixed   Returns item's new value on success or FALSE on\n *                     failure.\n */", S(16384),"getversion", T(Variant), S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.getversion.php )\n *\n * MemcachePool::getVersion() returns a string with server's version\n * \t\tnumber. Also you can use memcache_get_version() function.\n *\n * @return     mixed   Returns a string of server version number or FALSE\n *                     on failure.\n */", S(16384),"flush", T(Boolean), S(0), "expire", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.flush.php )\n *\n * MemcachePool::flush() immediately invalidates all existing items.\n * \t\tMemcachePool::flush() doesn't actually free any resources, it only\n * marks all the\n * \t\titems as expired, so occupied memory will be overwritten by new items.\n * Also\n * \t\tyou can use memcache_flush() function.\n *\n * @expire     int\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"setoptimeout", T(Boolean), S(0), "connect_timeoutms", T(Int64), NULL, NULL, S(0), "poll_timeoutms", T(Int64), "i:0;", "0", S(0), "udp_timeoutms", T(Int64), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.setoptimeout.php )\n *\n *\n * @connect_timeoutms\n *             int\n * @poll_timeoutms\n *             int\n * @udp_timeoutms\n *             int\n *\n * @return     bool\n */", S(16384),"close", T(Boolean), S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.close.php )\n *\n * MemcachePool::close() closes connection to memcached server. This\n * \t\tfunction doesn't close persistent connections, which are closed only\n * during\n * \t\tweb-server shutdown/restart. Also you can use memcache_close()\n * function.\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"getserverstatus", T(Int32), S(0), "host", T(String), NULL, NULL, S(0), "port", T(Int32), "i:0;", "0", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.getserverstatus.php\n * )\n *\n * MemcachePool::getServerStatus() returns a the servers\n * \t\tonline/offline status. You can also use memcache_get_server_status()\n * \t\tfunction.\n *\n * This function has been added to Memcache version 2.1.0.\n *\n * @host       string  Point to the host where memcached is listening for\n *                     \t\t\t\tconnections.\n * @port       int     Point to the port where memcached is listening for\n *                     \t\t\t\tconnections.\n *\n * @return     int     Returns a the servers status. 0 if server is failed,\n *                     non-zero\n *                     \t\t\totherwise\n */", S(16384),"setcompressthreshold", T(Boolean), S(0), "threshold", T(Int32), NULL, NULL, S(0), "min_savings", T(Double), "d:0.200000000000000011102230246251565404236316680908203125;", "0.2", S(0), NULL, S(16384), "/**\n * ( excerpt from\n * http://php.net/manual/en/memcachepool.setcompressthreshold.php )\n *\n * MemcachePool::setCompressThreshold() enables automatic compression\n * \t\tof large values. You can also use the\n * memcache_set_compress_threshold()\n * \t\tfunction.\n *\n * This function has been added to Memcache version 2.0.0.\n *\n * @threshold  int     Controls the minimum value length before attempting\n *                     to\n *                     \t\t\t\tcompress automatically.\n * @min_savings\n *             float   Specifies the minimum amount of savings to actually\n *                     store\n *                     \t\t\t\tthe value compressed. The supplied value must be\n *                     between 0 and 1.\n *                     \t\t\t\tDefault value is 0.2 giving a minimum 20%\n *                     compression savings.\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"getstats", T(Array), S(0), "type", T(String), "N;", "null", S(0), "slabid", T(Int32), "i:0;", "0", S(0), "limit", T(Int32), "i:100;", "100", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.getstats.php )\n *\n * MemcachePool::getStats() returns an associative array with server's\n * \t\tstatistics. Array keys correspond to stats parameters and values to\n * \t\tparameter's values. Also you can use memcache_get_stats() function.\n *\n * @type       string  The type of statistics to fetch. Valid values are\n *                     {reset,\n *                     \t\t\t\tmalloc, maps, cachedump, slabs, items, sizes}.\n *                     According to the\n *                     \t\t\t\tmemcached protocol spec these additional\n *                     arguments \"are subject to\n *                     \t\t\t\tchange for the convenience of memcache\n *                     developers\".\n * @slabid     int     Used in conjunction with type set to cachedump to\n *                     identify\n *                     \t\t\t\tthe slab to dump from. The cachedump command\n *                     ties up the server and is\n *                     \t\t\t\tstrictly to be used for debugging purposes.\n * @limit      int     Used in conjunction with type set to cachedump to\n *                     limit the\n *                     \t\t\t\tnumber of entries to dump.\n *\n * @return     map     Returns an associative array of server statistics or\n *                     FALSE on\n *                     \t\t\tfailure.\n */", S(16384),"getextendedstats", T(Array), S(0), "type", T(String), "N;", "null", S(0), "slabid", T(Int32), "i:0;", "0", S(0), "limit", T(Int32), "i:100;", "100", S(0), NULL, S(16384), "/**\n * ( excerpt from\n * http://php.net/manual/en/memcachepool.getextendedstats.php )\n *\n * MemcachePool::getExtendedStats() returns a two-dimensional\n * \t\tassociative array with server statistics. Array keys correspond to\n * host:port\n * \t\tof server and values contain the individual server statistics. A\n * failed\n * \t\tserver will have its corresponding entry set to FALSE. You can also\n * use the\n * \t\tmemcache_get_extended_stats() function.\n *\n * This function has been added to\n * \t\tMemcache version 2.0.0.\n *\n * @type       string  The type of statistics to fetch. Valid values are\n *                     {reset,\n *                     \t\t\t\tmalloc, maps, cachedump, slabs, items, sizes}.\n *                     According to the\n *                     \t\t\t\tmemcached protocol spec these additional\n *                     arguments \"are subject to\n *                     \t\t\t\tchange for the convenience of memcache\n *                     developers\".\n * @slabid     int     Used in conjunction with type set to cachedump to\n *                     identify\n *                     \t\t\t\tthe slab to dump from. The cachedump command\n *                     ties up the server and is\n *                     \t\t\t\tstrictly to be used for debugging purposes.\n * @limit      int     Used in conjunction with type set to cachedump to\n *                     limit the\n *                     \t\t\t\tnumber of entries to dump.\n *\n * @return     map     Returns a two-dimensional associative array of\n *                     server\n *                     \t\t\tstatistics or FALSE on failure.\n */", S(16384),"setserverparams", T(Boolean), S(0), "host", T(String), NULL, NULL, S(0), "port", T(Int32), "i:11211;", "11211", S(0), "timeout", T(Double), "i:0;", "0", S(0), "retry_interval", T(Int32), "i:0;", "0", S(0), "status", T(Boolean), "b:1;", "true", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.setserverparams.php\n * )\n *\n * MemcachePool::setServerParams() changes server parameters at\n * \t\truntime. You can also use the memcache_set_server_params() function.\n *\n * This\n * \t\tfunction has been added to Memcache version 2.1.0.\n *\n * @host       string  Point to the host where memcached is listening for\n *                     \t\t\t\tconnections.\n * @port       int     Point to the port where memcached is listening for\n *                     \t\t\t\tconnections.\n * @timeout    float   Value in seconds which will be used for connecting\n *                     to the\n *                     \t\t\t\tdaemon. Think twice before changing the default\n *                     value of 1 second - you\n *                     \t\t\t\tcan lose all the advantages of caching if your\n *                     connection is too slow.\n * @retry_interval\n *             int     Controls how often a failed server will be retried,\n *                     the\n *                     \t\t\t\tdefault value is 15 seconds. Setting this\n *                     parameter to -1 disables\n *                     \t\t\t\tautomatic retry. Neither this nor the persistent\n *                     parameter has any\n *                     \t\t\t\teffect when the extension is loaded dynamically\n *                     via dl().\n * @status     bool    Controls if the server should be flagged as online.\n *                     Setting\n *                     \t\t\t\tthis parameter to FALSE and retry_interval to -1\n *                     allows a failed server\n *                     \t\t\t\tto be kept in the pool so as not to affect the\n *                     key distribution\n *                     \t\t\t\talgoritm. Requests for this server will then\n *                     failover or fail\n *                     \t\t\t\timmediately depending on the\n *                     memcache.allow_failover setting. Default to\n *                     \t\t\t\tTRUE, meaning the server should be considered\n *                     online.\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"setfailurecallback", T(Boolean), S(0), "failure_callback", T(Variant), "N;", "null", S(0), NULL, S(16384), "/**\n * ( excerpt from\n * http://php.net/manual/en/memcachepool.setfailurecallback.php )\n *\n * MemcachePool::setfailurecallback() assigns a pool-specific failure\n * \t\tcallback which will be called when  a request fails. May be null in\n * order to\n * \t\tdisable callbacks. The callback receive arguments like:\n * \t\tfunction mycallback(host, tcp_port, udp_port, error, errnum)\n * \t\twhere host and error are strings or null, the other params are\n * integers.\n *\n * @failure_callback\n *             mixed   Allows the user to specify a callback function to\n *                     run upon\n *                     \t\t\t\tencountering an error. The callback is run\n *                     before failover is attempted.\n *                     \t\t\t\tThe function takes two parameters, the hostname\n *                     and port of the failed\n *                     \t\t\t\tserver.\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"addserver", T(Boolean), S(0), "host", T(String), NULL, NULL, S(0), "tcp_port", T(Int32), "i:11211;", "11211", S(0), "udp_port", T(Int32), "i:0;", "0", S(0), "persistent", T(Boolean), "b:0;", "false", S(0), "weight", T(Int32), "i:0;", "0", S(0), "timeout", T(Double), "i:1;", "1", S(0), "retry_interval", T(Int32), "i:0;", "0", S(0), "status", T(Boolean), "b:1;", "true", S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.addserver.php )\n *\n * MemcachePool::addServer() adds a server to the connection pool. The\n * \t\tconnection, which was opened using MemcachePool::addServer() will be\n * \t\tautomatically closed at the end of script execution, you can also\n * close it\n * \t\tmanually with MemcachePool::close(). You can also use the\n * memcache_add_server()\n * \t\tfunction.\n *\n * When using this method (as opposed to MemcachePool::connect() and\n * \t\tMemcachePool::pconnect()) the network connection is not established\n * until\n * \t\tactually needed. Thus there is no overhead in adding a large number of\n * \t\tservers to the pool, even though they might not all be used.\n *\n * Failover may\n * \t\toccur at any stage in any of the methods, as long as other servers are\n * \t\tavailable the request the user won't notice. Any kind of socket or\n * Memcached\n * \t\tserver level errors (except out-of-memory) may trigger the failover.\n * Normal\n * \t\tclient errors such as adding an existing key will not trigger a\n * \t\tfailover.\n *\n * This function has been added to Memcache version 2.0.0.\n *\n * @host       string  Point to the host where memcached is listening for\n *                     \t\t\t\tconnections. This parameter may also specify\n *                     other transports like\n *                     \t\t\t\tunix:///path/to/memcached.sock to use UNIX\n *                     domain sockets, in this case\n *                     \t\t\t\tport must also be set to 0.\n * @tcp_port   int     Point to the TCP port where memcached is listening\n *                     for\n *                     \t\t\t\tconnections. Set this parameter to 0 when using\n *                     UNIX or UDP domain sockets.\n * @udp_port   int     Point to the UDP port where memcached is listening\n *                     for\n *                     \t\t\t\tconnections. Set this parameter to 0 when using\n *                     UNIX od TCP domain sockets.\n * @persistent bool    Controls the use of a persistent connection. Default\n *                     to\n *                     \t\t\t\tTRUE.\n * @weight     int     Number of buckets to create for this server which in\n *                     turn\n *                     \t\t\t\tcontrol its probability of it being selected.\n *                     The probability is\n *                     \t\t\t\trelative to the total weight of all servers.\n * @timeout    float   Value in seconds which will be used for connecting\n *                     to the\n *                     \t\t\t\tdaemon. Think twice before changing the default\n *                     value of 1 second - you\n *                     \t\t\t\tcan lose all the advantages of caching if your\n *                     connection is too slow.\n * @retry_interval\n *             int     Controls how often a failed server will be retried,\n *                     the\n *                     \t\t\t\tdefault value is 15 seconds. Setting this\n *                     parameter to -1 disables\n *                     \t\t\t\tautomatic retry. Neither this nor the persistent\n *                     parameter has any\n *                     \t\t\t\teffect when the extension is loaded dynamically\n *                     via dl().\n *\n *                     Each failed\n *                     \t\t\t\tconnection struct has its own timeout and before\n *                     it has expired the\n *                     \t\t\t\tstruct will be skipped when selecting backends\n *                     to serve a request. Once\n *                     \t\t\t\texpired the connection will be successfully\n *                     reconnected or marked as\n *                     \t\t\t\tfailed for another retry_interval seconds. The\n *                     typical effect is that\n *                     \t\t\t\teach web server child will retry the connection\n *                     about every\n *                     \t\t\t\tretry_interval seconds when serving a page.\n * @status     bool    Controls if the server should be flagged as online.\n *                     Setting\n *                     \t\t\t\tthis parameter to FALSE and retry_interval to -1\n *                     allows a failed server\n *                     \t\t\t\tto be kept in the pool so as not to affect the\n *                     key distribution\n *                     \t\t\t\talgorithm. Requests for this server will then\n *                     failover or fail\n *                     \t\t\t\timmediately depending on the\n *                     memcache.allow_failover setting. Default to\n *                     \t\t\t\tTRUE, meaning the server should be considered\n *                     online.\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"sethashstrategy", T(Boolean), S(0), "hashstrategy", T(Int64), NULL, NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.sethashstrategy.php\n * )\n *\n * MemcachePool::setHashStrategy() allow you to change the default\n * \t\tstrategy for your MemcachePool instance\n *\n * @hashstrategy\n *             int     Hash strategy\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"sethashfunction", T(Boolean), S(0), "hashfunction", T(Int64), NULL, NULL, S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.sethashfunction.php\n * )\n *\n * MemcachePool::setHashFunction() allow you to change the default\n * \t\tfunction for your MemcachePool instance\n *\n * @hashfunction\n *             int     Hash function\n *\n * @return     bool    Returns TRUE on success or FALSE on failure.\n */", S(16384),"__destruct", T(Variant), S(0), NULL, S(16384), "/**\n * ( excerpt from http://php.net/manual/en/memcachepool.--destruct.php )\n *\n *\n * @return     mixed\n */", S(16384),NULL,NULL,NULL,
S(16384), "/**\n * ( excerpt from http://php.net/manual/en/class.memcachepool.php )\n *\n * Represents a connection to a set of memcache servers.\n *\n */", 
#elif EXT_TYPE == 3

#endif
